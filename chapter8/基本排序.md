## 插入排序

### 直接插入排序

```c
void InsertSort(int a[], int n) {
    int i, j, temp;
    // 默认第0个已经有序,则下标 i = 1 开始
    for (i = 1; i < n; i++) {
        // 如果当前值小于前一个值,则 temp = a[i]必会插入到前面
        if (a[i] < a[i - 1]) {
            temp = a[i];
            for (j = i - 1; j >= 0 && a[j] > temp; j--)
                a[j + 1] = a[j];
            a[j + 1] = temp;
        }
    }
}
```

### 带哨兵的直接插入排序

```c
void sentinel_InsertSort(int a[], int n) {
    int i, j;
    for (i = 2; i <= n; i++) {
        a[0] = a[i];
        for (j = i - 1; a[0] < a[j]; j--)
            a[j + 1] = a[j];
        a[j + 1] = a[0];
    }
}
```

### 带哨兵的折半插入排序

```c
void sentinel_InsertSort_half(int a[], int n) {
    int i,j, low, high, mid;
    for (i = 1; i <= n; i++) {
        a[0] = a[i];
        low = 1;
        high = i - 1;
        while (low <= high) {
            mid = high - (high - low) / 2; // 防止溢出
            if (a[mid]==a[0]) 
                low=mid+1; // 为了插入的稳定性,所以继续向右探测寻找可能插入的地方
            else if (a[mid]<a[0])
                low=mid+1;
            else if (a[mid]>a[0])
                high=mid-1;
        }
        // 折半一定会因为low>high停止,将[low,i-1]的元素全部右移,并且a[low]=a[0]
        for (j=i-1;j>=low;j--)
            a[j+1]=a[j];
        a[low]=a[0];
    }
}
```

### "同时" 处理两个表的希尔排序

```c
void ShellSort(int a[], int n) {
    int d, i, j;
    for (d = n / 2; d >= 1; d = d / 2)
        // 这里其实是处理第一个表的i和i+d元素之后切换表,
        // 随后开始处理第二个表的i+1和i+1+d个元素
        for (i = d + 1; i <= n; i++)
            if (a[i] < a[i - d]) {
                a[0] = a[i];
                for (j = i - d; j > 0 && a[0] < a[j]; j -= d)
                    a[j + d] = a[j];
                a[j + d] = a[0];
            }
}
```

### 先处理完一个表, 再处理第二个表的希尔排序

```c
void shellSort_no_switch(int a[], int n) {
    int d, i, j, k;
    for (d = n / 2; d >= 1; d = d / 2)
        for (k = 1; k <= d; k++) // 使用k对每一轮计数,一共d轮
            for (i = k + d; i < n; i += d) //这里相当于先处理k+d,k+2d......k+nd
                if (a[i] < a[i - d]) {
                    a[0] = a[i];
                    for (j = i - d; j > 0 && a[0] < a[j]; j -= d)
                        a[j + d] = a[j];
                    a[j + d] = a[0];
                }
}
```

## 冒泡排序

### 冒泡排序

```c
void BubbleSort(int a[], int n) {
    int i, j, temp, flag;
    for (i = 0; i < n - 1; i++) {
        flag = 0;
        for (j = 0; j < n - 1 - i; j++) {
            if (a[j ] > a[j+1]) {
                temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
                flag = 1;
            }
        }
        if (flag == 0)
            return;
    }
}
```

### 快速排序

```c
int Partition(int a[],int low,int high) {
    int pivot = a[low];
    while (low<high) {
        while (low<high && a[high]>=pivot)
            high--;
        a[low]=a[high];
        while (low<high && a[low]<=pivot)
            low++;
        a[high]=a[low];
    }
    a[low]=pivot;
    return low;
}

void QuickSort(int a[],int low,int high) {
    if (low<high) {
        int pivotpos = Partition(a,low,high);
        QuickSort(a,low,pivotpos-1);
        QuickSort(a,pivotpos+1,high);
    }
}
```

## 选择排序

### 简单选择排序

#### sqlist版

```c
void SelectSort(int a[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int min = i;
        for (int j = i + 1; j < n; j++)
            if (a[j] < a[min])
                min = j;
        if (min != i)
            swap(&a[i], &a[min]);
    }
}

```

#### linklist版

```c
void SelectSort_linklist(linklist* l) {
    if (*l == NULL || (*l)->next == NULL || (*l)->next->next == NULL) 
        return;
    lnode*head=*l;
    lnode*p_pre=head;

    while (p_pre->next!=NULL&&p_pre->next->next!=NULL) {
        lnode*min_pre=p_pre;
        lnode*min=p_pre->next;

        lnode*q_pre=p_pre->next;
        lnode*q=q_pre->next; // 类似于顺序表中j的地位,一直后移并与min比较
        while (q!=NULL) {
            if (q->data<min->data) {
                min=q;
                min_pre=q_pre;
            }
            q_pre=q;
            q=q->next;
        }
        if (min!=p_pre->next) {
            min_pre->next=min->next;
            min->next=p_pre->next;
            p_pre->next=min;
        }
        p_pre=p_pre->next;
    }
}
```

### 堆排序

调整堆

```c
void HeadAdjust(int a[], int k, int len) {
    a[0] = a[k];
    int i = 2 * k;

    while (i <= len) {
        if (i < len && a[i] < a[i + 1])
            i++;
        if (a[0] >= a[i])
            break;
        else {
            a[k] = a[i];
            k=i;
            i=2*k;
        }
    }
    a[k]=a[0];
}
```

建堆

```c
void BuildMaxHeap(int a[], int len) {
    for (int k = len / 2; k > 0; k--) {
        HeadAdjust(a, k, len);
    }
}
```

堆排序

```c
void HeapSort(int a[],int len) {
    BuildMaxHeap(a,len);
    for (int i=len;i>1;i--) {
        swap(&a[i],&a[1]);
        HeadAdjust(a,1,i-1);
    }
}
```

## 归并排序、基数排序和计数排序

### 归并排序

```c
int *b=(int *)malloc(n*sizeof(int));
```

```c
void Merge(int a[],int low,int mid,int high) {
    int i,j,k;
    for (k=low;k<=high;k++)
        b[k]=a[k];
    for (i=low,j=mid+1,k=i;i<=mid&&j<=high;k++) {
        if (b[i]<=b[j])
            a[k]=b[i++];
        else
            a[k]=b[j++];
    }
    while (i<=mid)
        a[k++]=b[i++];
    while (j<=high)
        a[k++]=b[j++];
}
```

```c
void MergeSort(int a[],int low,int high) {
    if (low<high){
        int mid=(low+high)/2;
        MergeSort(a,low,mid);
        MergeSort(a,mid+1,high);
        Merge(a,low,mid,high);
    }
}
```

### 基数排序

```c
// 懒得写,基本不考
```

### 计数排序

```c
void CountSort(int A[],int B[],int n,int k) { // k为待排序数据的最大值,后面会创建一个C[k]的数组
    int i,C[k];
    for (i=0;i<k;i++)
        C[i]=0;
    for (i=0;i<n;i++)
        C[A[i]]++;
    for (i=1;i<k;i++)
        C[i]=C[i]+C[i-1];
    for (i=n-1;i>=0;i--) {
        C[A[i]]=C[A[i]]-1;
        B[C[A[i]]]=A[i];
    }
}
```





## 内部排序算法的比较

__

|     类型     |     算法     |      最好情况       |      平均时间复杂度       |    最坏情况     |       空间复杂度        |       稳定性       |       最终性       |
| :----------: | :----------: | :-----------------: | :-----------------------: | :-------------: | :---------------------: | :----------------: | :----------------: |
| **插入排序** | 直接插入排序 |       $O(n)$        |         $O(n^2)$          |    $O(n^2)$     |         $O(1)$          | :white_check_mark: |        :x:         |
|              |   希尔排序   | $O(n^{1.3})$ (估计) | $O(n \log n) \sim O(n^2)$ |    $O(n^2)$     |         $O(1)$          |        :x:         |        :x:         |
| **交换排序** |   冒泡排序   |       $O(n)$        |         $O(n^2)$          |    $O(n^2)$     |         $O(1)$          | :white_check_mark: | :white_check_mark: |
|              |   快速排序   |   $O(n \log_2 n)$   |      $O(n \log_2 n)$      |    $O(n^2)$     | $O(\log_2 n) \sim O(n)$ |        :x:         | :white_check_mark: |
| **选择排序** | 简单选择排序 |      $O(n^2)$       |         $O(n^2)$          |    $O(n^2)$     |         $O(1)$          |        :x:         | :white_check_mark: |
|              |    堆排序    |   $O(n \log_2 n)$   |      $O(n \log_2 n)$      | $O(n \log_2 n)$ |         $O(1)$          |        :x:         | :white_check_mark: |
| **归并排序** |   归并排序   |   $O(n \log_2 n)$   |      $O(n \log_2 n)$      | $O(n \log_2 n)$ |         $O(n)$          | :white_check_mark: |        :x:         |
| **基数排序** |   基数排序   |     $O(d(n+r))$     |        $O(d(n+r))$        |   $O(d(n+r))$   |        $O(n+r)$         | :white_check_mark: |        :x:         |

r:基数的进制

d:待排序元素的"长度"



















